\documentclass{article}

\usepackage{amsmath}
\usepackage{graphicx}
\usepackage[colorlinks=true]{hyperref}
\usepackage{parskip}

\title{MP1 \\ CS 598: Parallel Migratable Objects}
\author{Fall 2014}
\date{Due date: Thursday, September 25, 10 PM CDT}

\begin{document}
\maketitle

\textbf{Description:} 
Parallel prefix can be used to implement a load balancing strategy. In this
assignment, you will implement a load balancer using parallel prefix. You
can implement the parallel prefix program given in the class slides or you
can implement your own version. 

%For this assignment you need to write a Charm++ program which does manual load
%balancing of integer numbers among elements of a 1D chare array using the 
%given parallel prefix code in the class slides or with your own parallel 
%prefix code. 

To implement the parallel prefix program, create a chare array of size $s$. Each
chare array element, $i$, generates $n_i$ random integers where the value of
$n_i$ is randomly generated between $min$ and $max$. The set of numbers generated
can be stored in an array or stl vector which we will refer to as $elems$. Your program takes $min$,
$max$, and $s$ as the command line arguments. Use $rand()$ function to generate random
numbers. This can create load imbalance depending on the value of $n_i$, which is
the number of $elems$ the $i^{th}$ chare array element owns. You will perform manual load
balancing using parallel prefix so as to distribute the $elems$ such that each
chare array element owns approximately  $\frac{n}{s}$ $elems$ where  $n = n_1 +
n_2 \cdots n_s$. \textbf{Note that the goal is not sorting or finding the
parallel prefix of the integers, it is just load balancing the integers that each chare owns while keeping the order of the integers the same globally.}\\


%First, you create a chare array of size $s$, where each chare $i$ in the chare array generates 
%(and hence owns) $n_i$ integer numbers. For every chare $i$, $n_i$ is a 
%randomly generated number between $min$ and $max$. 
%$min$, $max$ and $s$ are command line parameters. 
%Once $n_i$ is generated, chare $i$ generates $n_i$ random 
%integers (using rand()). In other words, each chare is creating a random number(between $min$ and $max$), and then creating that many more random numbers(not bounded). You can store the integers in a simple array or a stl vector. The task is to load balance the count
%of integer number among chares, i.e. if $n = n_1 + n_2 \cdots n_s$,
%each chare should get approximately $\frac{n}{s}$ integers. \\

The prefix sum and the average number of integer elements per chare array
element are used to
determine which integer elements each chare  array element needs to send.  To
obtain the average number of integers per chare array element, use reductions.
See
\href{http://charm.cs.uiuc.edu/manuals/html/charm++/4.html#SECTION01361000000000000000}{Charm++
reductions manual section} for details on reductions.\\ 

Figure~\ref{prefix} gives an example of how load balance can be achieved.\\

%Use reduction to get the average number of integers per chare. (See \href{http://charm.cs.uiuc.edu/manuals/html/charm++/4.html#SECTION01361000000000000000}{ Charm++ reductions manual section}.) The average should be useful in deciding which integers should be at which chares
%after load balancing. Use exclusive parallel prefix (count of integers in chare $i$
%is not counted in $prefix_i $) to decide which chare array element 
%should send which integers to which chare array element. Figure~\ref{prefix}
%may provide hints. \\


\begin{figure}[h]
\centering
\includegraphics[width=\textwidth]{prob1.pdf}
\caption{Load balancing integers among chares.}
\label{prefix}
\end{figure}


\textbf{Detailed Algorithm:} 

\begin{enumerate}

\item Create a chare array of size $s$ and generate the random integers on
each chare array element. Chare array element $i$ contains $n_i$ random integers
where $n_i$ is a random number between $min$ and $max$. $min$,
$max$ and $s$ are input arguments to your program.\\Here is the pseudocode for
this.\\$ n_i = rand() \%
(max - min) + min;\\ for(int\ k\ =\ 0;\ k\ <\ n_i;\ k++)\ {elems[k]\ =\ rand();}$
%\item  Create the initial integer elements on all chares

\item Execute the parallel prefix code on the number of elements in a chare array
element, $n_i$, to obtain the prefix sum. Note that prefix sum is not done on
$elems$ but on $n_i$. Let $p_i$ be the prefix sum of the
chare array element at index $i$ where $p_i = \sum\limits_{k=0}^{i-1} n_k$.
%\item On every chare, execute code to find prefix sum of number of elements ($p_i$ on chare $i$)

\item Find the average number of elements, $avg$, either using a reduction or
using the prefix sum.

\item Once you have the prefix sum, $p_i$, and $avg$, the data exchange required to achieve load
balance can be done as follows:
\begin{itemize}
\item consider a logical ranking of all the elements $0$ to $(n-1)$.
\item in a balanced distribution, elements with ranks $avg*i$ to $avg*(i +1)-1$ will reside on chare $i$
\item Every chare array element identifies the rank for $elems$, which is the integer elements it
owns. For chare array element $i$, the ranks of the integers in $elems$ would
range from $p_i$ to $p_i + (n_i - 1)$. The integer element with rank $j$ should be
sent to chare array element with index $\lfloor(j/avg)\rfloor$. Send these elements to
the correct destination using messages. Also send the starting rank so that the
destination can place these elements in the right location in the array. Do not
send the elements in separate messages. Instead bundle them together so that
all the elements from a chare array element that need to be sent to a
destination are sent in a single message.
\end{itemize}

% We need to make sure we check this, develop a rubric for this...

%\item Find average number of elements either using reduction or information from prefix sum (say avg).
%Data exchange to load balance can be done as follows:
%\begin{itemize}
%\item consider a logical ranking of the elements 1 to n where ranks 0 to $N_1$ - 1 are on chare 1, $N_1$ to $N_2-1$ are on chare 2, and so on..
%\item in the load balanced distribution, elements with ranks $avg*i$ to $avg*(i +1)-1$ will reside on chare $i$
%\end{itemize}


%\item On every chare which initially contains elements with ranks $p_i$ to $p_(i+1) - 1$, find the final destination of the elements (element with rankj should go to chare $floor(j/avg)$ ) and send them to the destination chares (also send their starting rank, so the detination can store it in the right place). Do not send individual values in separate messages.. bunch together all the data chare $x$ sends to chare y in a single method invocation.

\item Upon receiving a message, every chare array element copies these new
elements into a new list in their correct position (using the rank provided by
the sender).
Note, we are simply load balancing the number of integers contained by each chare array element
and the original overall order of the integers should be preserved.
%\item On every chare, receive the incoming messages and copy them to a new element list in their correct position (using the ranks)
 
\end{enumerate}

\emph{Correctness Test}: The checksum of the integers in the beginning
should be the same as the checksum of the integers after load balancing.
Use the \emph{bitvec\_xor} operation over all the integers to compute a checksum (see the \href{http://charm.cs.uiuc.edu/manuals/html/charm++/4.html#SECTION01361000000000000000}{ Charm++
reductions} section in the manual). \\

\emph{Exit condition}: You can either use Quiescence Detection (with the CkStartQD(..) function, for more
information about QD please see the related
\href{http://charm.cs.illinois.edu/manuals/html/charm++/12.html#SECTION02350000000000000000}{manual
section}) to terminate or your own method to detect when
the load balancing is complete. \\


\textbf{Running your code:}
The program should have the following signature: \\
\textit{./charmrun ./mp1 +p4 chare-array-size min max} \\

You should test your code on Taub cluster up to 64 processors. You can start with a small
number of processors and once you make sure your algorithm works, you can test
with more number of processors. You can use 1024 as
\textit{chare-array-size} and \textit{min/max} in the range of [5,000 - 30,000].
\\ \\ \\

%\pagebreak

\textbf{A Case Study:} 

\begin{figure}[h]
\centering
\includegraphics[width=\textwidth]{before_balance.png}
\caption{Before load balancing.}
\label{prefix}
\end{figure}

After load balancing, all the reds will be in Chare 0, all greens in Chare 1, all blues in Chare2. \\
Chare 0 will not send anything.\\
Chare 1 will send everything [3-4] to Chare 0.\\
Chare 2 will send [5] to Chare 0 and [6-11] to Chare 2.\\

\textbf{P} = Exclusive Prefix Sum \\

\textbf{Fact \#1:}
If Chare $n$ has $k$ integers, the global rank of the integers are $[P, P+k-1]$.

\textbf{Fact \#2:}
After the load balance, Chare $n$ needs to have values in the range 
$[thisIndex()*avg, (thisIndex()+1)*avg-1]$\\

\begin{figure}[h]
\centering
\includegraphics[width=\textwidth]{after_balance.png}
\caption{After load balancing.}
\label{prefix}
\end{figure}


\textbf{ Load Balance Algorithm: }
\begin{itemize}
\item Decide which part of your array belongs to which chare by looking at the global rank of your local array.
\begin{itemize}
\item E.g: For Chare 3, local integers have global rank of [5-17]
\item $[5]$ should be in Chare 0 and [6-11] should be in Chare 1 because of FACT \#2.
\end{itemize}
\item Extract values from local array and send it to the chare together with the index information. 
\begin{itemize}
\item int[] values, int $start\_index$, int $end\_index$
\end{itemize}


\item Receiving side: The final array can be pre-allocated according to the average. Whenever a chare receives data, put into the pre-allocated place looking at the index information

\end{itemize}



\textbf{Note:}
Here is a suggested way for the case where the total number of integers is not
evenly divisible by $s$ (size of the chare array).
\begin{itemize}
\item Store the average as double, not as integer.
\item When calculating the index range $[thisIndex()*avg, (thisIndex()+1)*avg-1]$, the values needs to be rounded down.\\
%Even if the avg is not an integer number, the algorithm should still distribute the values evenly, the extra numbers will not be accumulated at the end.
\end{itemize}


\textbf{Another example showing global index values:}

\begin{figure}[h]
\centering
\includegraphics[width=\textwidth]{example.png}
\label{prefix}
\end{figure}
\textbf{Global index values:} $[thisIndex()*avg, (thisIndex()+1)*avg-1]$\\
Chare 0: [0-20] $->$ 21 values after balance\\
Chare 1: [21-42] $->$ 22 values after balance\\
Chare 2: [43-64] $->$ 22 values after balance\\


\pagebreak


\textbf{Submission:}
Create an mp1 directory in your SVN repository folder and add your code into
that folder and check in the your code.
\begin{itemize}
\item  For each file F you create, that you want to check in, do: \\
        \textit{svn add F}\\
        and frequently (after you have modified F, and have the next better
        version) do:\\ 
        \textit{svn ci F}
\item  There will be a penalty for late submissions.
\end{itemize}

\end{document}
