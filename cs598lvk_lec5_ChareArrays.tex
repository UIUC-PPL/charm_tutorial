\documentclass{beamer}
\usepackage{etex}
\reserveinserts{28}

\input{include_pkg}
\input{include_cfg}
\input{include_theme}
\input{include_cmd}

\title{Chare Arrays}

\author[Laxmikant V.~Kale]{
Laxmikant V.~Kale
}
\date{\today}

\begin{document}

\begin{frame}[fragile]
  \frametitle{Chare Arrays}
  \begin{itemize}
    \item Indexed collections of chares
      \begin{itemize}
      \item Every item in the collection has a unique index and proxy
      \item Can be indexed like an array or by an arbitrary object
      \item Can be sparse or dense
      \item Elements may be dynamically inserted and deleted
      \end{itemize}
    \item For many scientific applications, collections of chares are a
      convenient abstraction
    \item Instead of creating networks of chares that learn about each other
      (by sending proxies to each other), each element in a chare array knows
      about all the others
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Chare Array Location}
  \begin{itemize}
  \item By default, chare arrays are distributed to the processors in a
    ``blocked'' distribution
  \end{itemize}
  \begin{center} \includegraphics[width=0.8\textwidth]{figures/blockedDist.pdf} \end{center}
  \begin{itemize}
  \item A initial mapping function can be specified (input is the index, output
    is the processor)
    \begin{itemize}
    \item Called the \emph{home PE} of the element
    \end{itemize}
  \item Chare array elements can be migrated by the user or the runtime (load balancing)
  \end{itemize}
\end{frame}



\input{charmSyntax2}

\begin{frame}[fragile]
  \frametitle{Prefix Sum Algorithm}
  \begin{itemize}
  \item Given array A[0..N-1], produce B[N], such that B[k] is the sum of all
  elements of A up to A[k]
  \end{itemize}
    \begin{lstlisting}
    B[0] = A[0];
    for (i=1; i<N; i++) 
    B[i] = B[i-1] + A[i];
    \end{lstlisting}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Parallel Prefix Sum Algorithm}
  \begin{itemize}
  \item Data dependency from iteration to iteration.
  \item How can this be parallelized at all?
    \begin{lstlisting}
    B[0] = A[0];
    for (i=1; i<N; i++) 
    B[i] = B[i-1] + A[i];
    \end{lstlisting}
    \item It looks like the problem is inherently sequential, but theoreticians
    came up with a beautiful algorithm called recursive doubling or just
    parallel prefix
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Parallel Prefix: Recursive Doubling Algorithm}
  \begin{center}
  \includegraphics[width=0.8\textwidth]{figures/par_prefix_sum.png} 
  \end{center}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Parallel Prefix: Engineering}
  \begin{itemize}
    \item Issue : N \textgreater \textgreater  P
    \item Recursive doubling : NaÃ¯ve implementation
    Operation count: log(N) . N
    \item A better implementation, well-engineered:
    \begin{itemize}
    \item Take blocking of data into account
    \item Each processor calculate its sum, then 
            Participates in a parallel algorithm (with P numbers) 
            to get sum to its left, and then adds to all its elements
    \item N + log(P) + N: Only doubling of operation Count
    \item What did we do?
    Same algorithm, better parallelization/engineering
    \end{itemize}
  \end{itemize}
\end{frame}


\begin{frame}[fragile]
  \frametitle{Parallel Prefix Example: prefix.ci}
  \lstinputlisting{code/par-prefix-wrong/prefix.ci}
\end{frame}

\begin{frame}[allowframebreaks]
  \frametitle{Wrong Parallel Prefix: Why? prefix.C}
  \lstinputlisting[basicstyle=\tiny]{code/par-prefix-wrong/prefix.C}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Parallel Prefix Example, Correct Version: prefix.ci}
  \lstinputlisting{code/par-prefix-no-sdag/prefix.ci}
\end{frame}

\begin{frame}[allowframebreaks]
  \frametitle{Parallel Prefix Example: prefix.C}
  \lstinputlisting[basicstyle=\tiny]{code/par-prefix-no-sdag/prefix.C}
\end{frame}


\end{document}
