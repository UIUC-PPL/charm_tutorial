\documentclass{beamer}
\usepackage{etex}
\reserveinserts{28}

\input{include_pkg}
\input{include_cfg}
\input{include_theme}
\input{include_cmd}

\title{Load Balancing in Charm++}

\author[Laxmikant V.~Kale]{
Laxmikant V.~Kale
}
\date{\today}

\begin{document}

\begin{frame}[fragile]
  \frametitle{Observations: Parallel applications}
    \begin{itemize}
    \item Obtaining best performance on parallel computers is difficult due to properties exhibited by applications 
      \begin{itemize}
        \item Multi-resolution - variation in task granularity
        \item Multi-module - loosely connected diverse tasks
        \item {\color{red} Dynamic/adaptive: to handle application variation}
        \item {\color{red} Adapt to a volatile computational environment}
        \item Exploit heterogeneous architecture - GPUs, MICs
      \end{itemize}
    \item Consequences:
      \begin{itemize}
        \item Must support automated resource management
        \item This lecture is focussed on {\color{red} load balancing}
      \end{itemize}
    \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{What is load imbalance?}
  \begin{columns}
  \begin{column}{.6\textwidth} 
  \centering
  \includegraphics[width=\textwidth]{cs598lvk/diagrams/load_imbalance.jpg}
  \end{column}
  \begin{column}{.4\textwidth} 
  \begin{itemize}
  \item Application completes only when all processor finishes 
  \item Different processors gets variable work
  \item Resource wasted in waiting
  \end{itemize}
  \end{column}
  \end{columns}
\end{frame}

\begin{frame}[fragile]
  \frametitle{What is desirable?}
  \centering
  \includegraphics[width=.7\textwidth]{cs598lvk/diagrams/balanced.png}
  \begin{itemize}
  \item Work is evenly divided among processors to make best use of the available resources
  \item How - Static and Dynamic Load balancing
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Static Mapping for Load Balancing}
    \begin{itemize}
      \item In some applications, load pattern does not change much as computation progresses
      \begin{itemize}
        \item You, the programmer, may want to control which chare lives on which processors
        \item This is also true when  load may evolve over time, but you want to control initial placement of chares
      \end{itemize}
      \item The feature in Charm++ for this purpose is called \textbf{Map
      Objects}
      \item Sec. 13.2.2 of the Charm++ manual
    \end{itemize}
\end{frame}

\begin{frame}[fragile]
    \frametitle{CkArrayOptions - customizing array creation}
    \begin{itemize}
      \item To specify static initial mapping, we must first learn this feature
      \begin{itemize}
        \item Whenever a chare array is created, one can pass an optional
        parameter of type CkArrayOptions
      \end{itemize}
    \end{itemize}
      \begin{lstlisting}
      CkArrayOptions opts(numElements); //array to be created with numElements chares
      //set other properties of opts (discussed later in the course)
      P = CProxy_A::CkNew(parameters, opts);
      \end{lstlisting}
    \begin{itemize}
      \item Many propperties of arrays can be set using this method.
      \item {\color{red} In particular, we can specify a map object}
    \end{itemize}
\end{frame}

\begin{frame}[fragile]
    \frametitle{CkArrayMap - base class of all map objects}
    \begin{lstlisting}
    class CkArrayMap : public Group
    {
      public:
      //......
      
      //Return the processor number for this element of this array
      virtual int procNum(int arrayHdl, const CkArrayIndex element);

      //Return an ``arrayHdl'', given some information about the array
      virtual int registerArray(CkArrayIndex numElements, CkArrayID aid);
    }
    \end{lstlisting}
    \begin{itemize}
    \item If you want to specify a map for a chare array you are about to
    create, you must first define a subclass of CkArrayMap
    \item It is a “Group”.. More on that much later
    \item You don’t need to know any more than inheriting from it for now
    \end{itemize}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Defining your own map}
    \begin{lstlisting}
     class BlockMap : public CkArrayMap
     { public:
       BlockMap(void) {}
       BlockMap(CkMigrateMessage *m){}

       // place elements in blocks of 32
       int procNum(int /*arrayHdl*/,const CkArrayIndex& idx) {
           int elem=*(int *)idx.data();
           int penum =  (elem/32) % CkNumPes();
           return penum;
       }
       int registerArray(CkArrayIndex& numElements,CkArrayID aid) 
       { return 0; }
     };
    \end{lstlisting}
    \begin{itemize}
        \item \texttt{CkArrayIdx} is a datatye that’s normally used by the system. You
        can peek into it to extract indices. The example works for 1D array
    \end{itemize}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Putting them alll together}
    \begin{lstlisting}
      //Create the map group
      CProxy_BlockMap myMap=CProxy_BlockMap::ckNew();
      //Make a new array using that map
      CkArrayOptions opts(nElements);
      opts.setMap(myMap);
      a1=CProxy_A1::ckNew( parameters,opts);
    \end{lstlisting}
    \begin{itemize}
    \item Create a map object, 
    \item pass it to an \texttt{CkArrayOptions} object (opts here), and then 
    \item pass that to \texttt{ckNew}
    \end{itemize}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Why is CkArrayMap an object}
    \begin{itemize}
      \item It looks like a function.. Given an index, return a PE (processor
      number)
      \item In many simple cases, that is enough
      \item In general, you may want to remember some data in state information, so you can construct the answer quickly
      \item The system may ask you for this information at creation, but also later during method invocation
    \end{itemize}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Exercises}
    \begin{itemize}
        \item Write a map object for cyclic distribution of a 1D chare array
        \item Write a map object for a 2D chare array in a block fashion, ensuring that they are not heavily load imbalanced, even when running on non-square number of processors
        \begin{itemize}
            \item Should work for any combination of array sizes and number of processors
        \end{itemize}
        \item Extend the previous one for the case where each processor has a x,y,z coordinate (the physical network is a torus, for example)
    \end{itemize}
\end{frame}

\input{dynamicLB}

\end{document}
